<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf8" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width" />
    <title>
      
        c++学习笔记——多态与虚函数 | Felt's blog
      
    </title>
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    
      <link rel="apple-touch-icon"
            sizes="180x180"
            href="/images/apple-touch-icon.png" />
    
    
      <link rel="icon"
            type="image/png"
            sizes="32x32"
            href="/images/favicon-32x32.png" />
    
    
      <link rel="icon"
            type="image/png"
            sizes="16x16"
            href="/images/favicon-16x16.png" />
    
    
      <link rel="mask-icon"
            href="/images/logo.svg"
            color="" />
    
    
    
      
  <style>
    @font-face {
        font-family:sourceHanSerif;
        src: url(/font/normal.ttf);
        font-weight: normal;
    }
  </style>

  <style>
    @font-face {
        font-family:sourceHanSerif;
        src: url(/font/bold.ttf);
        font-weight: bold;
    }
  </style>


    
    <link rel="stylesheet"
          type="text/css"
          href='/css/layout.css' />
    
    
  <link rel="stylesheet" type="text/css" href="/css/post.css"/>
  

  <meta name="generator" content="Hexo 7.3.0"></head>
  <body>
    
      <div id="search-mask" style="display:none">
  <div class="search-main" id="search-main">
    <div class="search__head">
      <div class="search-form">
        <svg t="1706347533072"
             class="icon"
             viewBox="0 0 1024 1024"
             version="1.1"
             xmlns="http://www.w3.org/2000/svg"
             p-id="7828"
             width="20"
             height="20">
          <path d="M685.6 660.336l155.152 155.168a16 16 0 0 1 0 22.624l-11.312 11.328a16 16 0 0 1-22.624 0l-158.528-158.544a289.792 289.792 0 0 1-165.152 51.36C322.336 742.256 192 611.904 192 451.12 192 290.336 322.336 160 483.136 160c160.784 0 291.12 130.336 291.12 291.136 0 82.112-33.984 156.272-88.672 209.2z m-202.464 33.92c134.272 0 243.12-108.848 243.12-243.12C726.256 316.848 617.408 208 483.136 208 348.848 208 240 316.848 240 451.136c0 134.272 108.848 243.12 243.136 243.12z" fill="#000000" p-id="7829">
          </path>
        </svg>
        <input id="search-input" placeholder="搜索文章">
        <svg t="1706361500528"
             id="search-clear"
             class="icon"
             viewBox="0 0 1024 1024"
             version="1.1"
             xmlns="http://www.w3.org/2000/svg"
             p-id="4351"
             width="20"
             height="20">
          <path d="M512 562.688l-264.2944 264.2944-50.688-50.688L461.312 512 197.0176 247.7056l50.688-50.688L512 461.312l264.2944-264.2944 50.688 50.688L562.688 512l264.2944 264.2944-50.688 50.688L512 562.688z" fill="#00" p-id="4352">
          </path>
        </svg>
      </div>
    </div>
    <div class="search__body" id="search-result"></div>
    <div class="search__foot"></div>
  </div>
</div>

    
    
    <div class=head>
      <div class="nav">
        <a href='/' class="nav-logo">
          <img alt="logo" height="60px" width="60px" src="/images/logo.svg" />
        </a>
        <input id="navBtn" type="checkbox" />
        <div class="nav-right">
          
            <div class="search-outer">
  <div class="search" id="search-btn">
    <svg t="1706347533072"
         class="icon"
         viewBox="0 0 1024 1024"
         version="1.1"
         xmlns="http://www.w3.org/2000/svg"
         p-id="7828"
         width="20"
         height="20">
      <path d="M685.6 660.336l155.152 155.168a16 16 0 0 1 0 22.624l-11.312 11.328a16 16 0 0 1-22.624 0l-158.528-158.544a289.792 289.792 0 0 1-165.152 51.36C322.336 742.256 192 611.904 192 451.12 192 290.336 322.336 160 483.136 160c160.784 0 291.12 130.336 291.12 291.136 0 82.112-33.984 156.272-88.672 209.2z m-202.464 33.92c134.272 0 243.12-108.848 243.12-243.12C726.256 316.848 617.408 208 483.136 208 348.848 208 240 316.848 240 451.136c0 134.272 108.848 243.12 243.136 243.12z" fill="#000000" p-id="7829">
      </path>
    </svg>
    <span>搜索</span>
    <span class="search-shortcut-key">Ctrl K</span>
  </div>
</div>

          
          <div class="nav-menu">
            
              
                <a class="nav-menu-item" href="/note">学习笔记</a>
              
                <a class="nav-menu-item" href="/project">项目</a>
              
            
            
          </div>
        </div>
        <label class="nav-btn" for="navBtn"></label>
      </div>
    </div>
    <div class="body">
      
  <article class="post-content">
    <div class="post-inner--toc">
      <div class="post-content__head">
        <div class="post-title">c++学习笔记——多态与虚函数</div>
        <div class="post-info">
          
  <a href="/tags/c/" class="post-tag">#c++</a>


          <span class="post-date">2024-09-10</span>
        </div>
      </div>
      
        <aside class="toc-outer">
          <div class="toc-title">目录</div>
          <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="post-toc-text">多态与虚函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9D%9E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="post-toc-text">虚函数与非虚函数的区别：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%BC%BA%E7%82%B9"><span class="post-toc-text">虚函数缺点:</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Note%EF%BC%9A"><span class="post-toc-text">Note：</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="post-toc-text">纯虚函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%9D%E6%83%B3%E5%8C%BA%E5%88%AB%EF%BC%9A%E7%BB%91%E5%AE%9A"><span class="post-toc-text">虚函数与普通函数的思想区别：绑定</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%97%A9%E6%9C%9F%EF%BC%88%E9%9D%99%E6%80%81%EF%BC%89%E7%BB%91%E5%AE%9A"><span class="post-toc-text">早期（静态）绑定</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%8E%E6%9C%9F%EF%BC%88%E5%8A%A8%E6%80%81%EF%BC%89%E7%BB%91%E5%AE%9A"><span class="post-toc-text">后期（动态）绑定</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="post-toc-text">虚函数实现的底层原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%99%84%E5%BD%95"><span class="post-toc-text">附录</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#final"><span class="post-toc-text">final</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="post-toc-text">虚拟析构函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BF%BD%E7%95%A5%E8%99%9A%E5%87%BD%E6%95%B0"><span class="post-toc-text">忽略虚函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="post-toc-text">虚基类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%8D%E7%A7%B0%E9%9A%90%E8%97%8F"><span class="post-toc-text">名称隐藏</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E5%86%99"><span class="post-toc-text">友元函数的重写</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="post-toc-text">实例</span></a></li></ol></li></ol></li></ol>
          <a href="#" class="toc-top">回到顶部</a>
        </aside>
      
      <div class="post-content__body">
        
          <div class="post-gallery">
            
          </div>
        
        <h2 id="多态与虚函数"><a href="#多态与虚函数" class="headerlink" title="多态与虚函数"></a>多态与虚函数</h2><p><strong>多态</strong>：实体具有多种形态的能力，在c++中具体表现就是函数具有多种形态。<br>多态的实现方式主要有两种：<strong>编译时多态</strong>（静态多态）和<strong>运行时多态</strong>（动态多态）：<br>	<strong>编译时多态性</strong>：指由编译器解析的多态性形式。其中包括<strong>函数重载解析以及模板解析</strong>。<br>	<strong>运行时多态性</strong>：是指在运行时解析的多态性形式。这包括<strong>虚拟函数解</strong>析。</p>
<p><strong>虚函数</strong>：在基类中使用关键字virtual指明函数为虚函数，然后在派生类中重写虚函数。当通过<strong>指针或引用</strong>调用虚函数时，会基于指针（或引用）<strong>指向的对象的类型</strong>来动态选择（<strong>即动态绑定</strong>）。<br>例如<code>A&amp; rBase&#123; c &#125;;</code>，运行时编译器会调用 A 和 C 之间派生最多的匹配函数<br>	- 仅当通过<strong>指针或引用</strong>调用虚拟成员函数时，虚函数解析才有效。<br>	- 虚函数是为了解决编译时期指针或引用<strong>不能确定它所指向的对象的具体类型</strong>，需要在运行时期在对象构造后确定对象的<strong>实际类型</strong>后，根据其来选择对应的函数版本</p>
<h4 id="虚函数与非虚函数的区别："><a href="#虚函数与非虚函数的区别：" class="headerlink" title="虚函数与非虚函数的区别："></a><strong>虚函数与非虚函数的区别：</strong></h4><p>主要的区别在于<strong>绑定方式</strong>：</p>
<ul>
<li>非虚函数的解析是编译时就确定的，基于指针（或引用）的类型来静态选择（静态绑定）</li>
<li>虚函数的解析是在运行时确定的，基于指针（或引用）指向的对象的类型来动态选择（动态绑定）</li>
</ul>
<h4 id="虚函数缺点"><a href="#虚函数缺点" class="headerlink" title="虚函数缺点:"></a>虚函数缺点:</h4><ol>
<li><strong>时间开销</strong>：解析虚拟函数调用比解析常规函数调用花费的时间更长，虚函数的调用需要两个额外的步骤</li>
<li><strong>空间开销</strong>：编译器还必须为具有虚函数的类的每个对象分配一个额外的虚指针，对象的大小就会增加一个指针的大小（指针类型32位系统中占用4字节，在64位系统中占用8字节），每个类还要生成一个虚函数表</li>
</ol>
<h4 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h4><ul>
<li>不管虚函数是否用到，<strong>派生类都要给每个虚函数定义</strong><br>  -这是因为动态绑定，要在运行时才能指定调用哪个版本的虚函数<br>  -<strong>基类中的虚函数在派生类中隐含地也是一个虚函数</strong>，即使派生类的对应函数没有显式标记为 virtual。</li>
<li><strong>派生类中虚函数的形参和返回类型也必须与基类函数匹配</strong>。否则派生类的虚函数将不会override基类的虚函数，因为编译器将这两个函数视为不同的函数<ul>
<li>除非基类B的虚函数返回类型是类本身的引用B&amp;或指针B* ，则派生类D可以返回自己的类型即D&amp;或D*</li>
<li>但也要要求D到B的类型转换是可访问的。</li>
<li>例如下面B的两个函数都不被视为重写</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string_view <span class="title">getName1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string_view <span class="title">getName2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string_view <span class="title">getName1</span><span class="params">(<span class="type">short</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// note: parameter is a short</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string_view <span class="title">getName2</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// note: function is const</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>派生类重写的虚函数尽量使用<strong>override</strong>，放置在虚函数签名之后（类似于函数const的用法）<ul>
<li>override可以解决上一个隐患：如果函数没有重写基类函数（或应用于非虚函数），编译器会将该函数标记为错误</li>
<li>由于 override 说明符隐含 virtual，因此被重写的虚函数前面无需再加上 virtual</li>
<li>例如</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string_view <span class="title">getName1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string_view <span class="title">getName2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> std::string_view <span class="title">getName3</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">std::string_view <span class="title">getName1</span><span class="params">(<span class="type">short</span> <span class="type">int</span> x)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// compile error, function is not an override</span></span><br><span class="line">	<span class="function">std::string_view <span class="title">getName2</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// compile error, function is not an override</span></span><br><span class="line">	<span class="function">std::string_view <span class="title">getName3</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// okay, function is an override of A::getName3(int)</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>不要<strong>从构造函数或析构函数中调用虚函数</strong> <ul>
<li>例如，在创建 Derived 类时，首先构造 Base 部分。如果要从 Base 构造函数调用虚拟函数，并且尚未创建类的 Derived 部分，则它将无法调用函数的 Derived 版本。在 C++ 中，它将改为调用 Base 基类版本。</li>
</ul>
</li>
<li>虚函数可以声明为<code>inline</code>，但实际内联的可能性有限。因为在编译时无法知道确切的虚函数实现，因此很难将虚函数内联。对于需要多态性的场景，通常不建议将虚函数声明为<code>inline</code>。</li>
<li>静态函数不能定义为虚函数。因为静态函数不与任何类对象关联，所以它们不具备<code>this</code>指针和虚函数表指针。<br>我们什么时候使用函数重载与函数重写（虚函数）？<ol>
<li>当我们需要成员或非成员函数在传递不同类型的参数时表现不同时，就会使用函数重载。</li>
<li>当我们需要基类和派生类之间需要共享相同的方法名，但实现可能不同的情况，即成员函数在隐式对象是派生类时表现不同时，使用函数重写。</li>
</ol>
</li>
</ul>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><ul>
<li><strong>纯虚函数</strong>（pure virtual）：清晰地告诉用户当前的函数是没有实际意义的。<strong>纯虚函数无需定义</strong>，没有函数体，只用在函数体声明后<code>=0</code>就可以将一个虚函数说明为纯虚函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> =<span class="number">0</span> ;    <span class="comment">//也可以给继承的虚函数加上=0，重声明其是纯虚函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>含有纯虚函数的类是<strong>抽象基类</strong>（abstract base class）。抽象类不能实例化（不能创建抽象基类的对象）<ul>
<li>其派生类都必须为纯虚函数定义一个主体，否则该派生类也将被视为抽象基类。</li>
</ul>
</li>
<li>纯虚函数也可以提供定义，但必须在类外部单独定义</li>
<li>在虚函数表中，纯虚函数指针的值取决于编译器，一般是0或者指向一个特殊的函数，使得调用纯虚函数时触发运行时错误。</li>
<li><strong>纯虚函数使用场景</strong>：<ul>
<li>主要用于定义接口，强制派生类实现这些函数。在实际开发中，可以先定义一个抽象类，只完成部分功能，未完成的功能交给派生类来完成，这部分功能往往是基类是不需要的，虽然抽象基类没能完成，可是却要求派生类来完成。</li>
<li>例如下面的<strong>接口类</strong>，任何从 IErrorLog 继承的类都必须为所有三个函数提供实现才能进行实例化。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IErrorLog</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">bool</span> <span class="title function_">openLog</span><span class="params">(<span class="built_in">std</span>::string_view filename)</span> = <span class="number">0</span>;</span><br><span class="line">    virtual <span class="type">bool</span> <span class="title function_">closeLog</span><span class="params">()</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual <span class="type">bool</span> <span class="title function_">writeError</span><span class="params">(<span class="built_in">std</span>::string_view errorMessage)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    virtual ~IErrorLog() &#123;&#125; <span class="comment">// make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>只有类中的虚函数才能被定义为纯虚函数，普通成员函数和顶层函数均不能被声明为纯虚函数。</li>
</ul>
<h2 id="虚函数与普通函数的思想区别：绑定"><a href="#虚函数与普通函数的思想区别：绑定" class="headerlink" title="虚函数与普通函数的思想区别：绑定"></a>虚函数与普通函数的思想区别：绑定</h2><h4 id="早期（静态）绑定"><a href="#早期（静态）绑定" class="headerlink" title="早期（静态）绑定"></a>早期（静态）绑定</h4><p>程序编译时，机器语言的每一行都有自己唯一的顺序地址，因此每个函数最终都有一个唯一的地址。<br><strong>绑定</strong>（binding）是将名称与此类属性相关联的过程。<br>	<strong>函数绑定</strong>是确定与函数调用关联的函数定义的过程。<br>	实际调用绑定函数的过程称为 <strong>dispatching</strong>。<br>	<br><strong>早期绑定</strong>：在编译时期的函数绑定。<br>	- 在 C++ 中，当直接调用非成员函数或非虚拟成员函数时，<strong>编译器可以确定哪个函数定义应与调用匹配</strong>，<strong>函数就可以在编译时执行</strong>。<br>	- 然后，编译器可以生成机器语言指令，告诉 CPU 直接跳转到该函数的地址。</p>
<h4 id="后期（动态）绑定"><a href="#后期（动态）绑定" class="headerlink" title="后期（动态）绑定"></a>后期（动态）绑定</h4><p><strong>后期绑定</strong>: 指针或引用调用的虚拟函数调用在运行之前无法解析，即编译器不能仅根据静态类型信息来确定被调用的函数，而必须使用动态类型信息进行解析。</p>
<ul>
<li>获得后期绑定的一种方法是使用<strong>函数指针</strong>。<ul>
<li>简单回顾一下函数指针，函数指针是一种指向函数而不是变量的指针。通过函数指针调用函数也称为间接函数调用。</li>
</ul>
</li>
<li>函数指针调用如下：<ul>
<li>在实际调用 <code>fcn（5）</code> 时，编译器在编译时不知道正在调用的是什么函数，因为编译器只知道指针fcn的地址，并不知道其调用函数的地址。</li>
<li>相反，在运行时，<strong>将对函数指针fcn持有的地址</strong>中存在的任何函数进行间接函数调用。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printValue</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> fcn &#123; printValue &#125;; <span class="comment">// create a function pointer and make it point to function printValue</span></span><br><span class="line">    fcn(<span class="number">5</span>);                  <span class="comment">// invoke printValue indirectly through the function pointer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>缺点：后期绑定的效率略低，因为它涉及额外的间接级别。<ul>
<li>通过早期绑定，CPU 可以直接跳转到函数的地址。</li>
<li>对于后期绑定，程序必须读取指针中保存的地址，然后跳转到该地址。</li>
</ul>
</li>
</ul>
<h2 id="虚函数实现的底层原理"><a href="#虚函数实现的底层原理" class="headerlink" title="虚函数实现的底层原理"></a>虚函数实现的底层原理</h2><p><strong>虚表</strong>是函数的查找表，是一个函数指针数组，用于以动态&#x2F;后期绑定方式解析函数调用。虚函数解析有时称为<strong>动态调度</strong>。<br>	- 每个使用虚函数的类（包括使用虚函数的派生类）都有自己相应的独立虚表。<br>		- 抽象类也有虚表，抽象类的构造函数或析构函数可以调用虚函数<br>	- 虚表包含类中所有可调用<strong>虚函数地址入口</strong>。<br>	- 虚表在编译时期构造，存储在<strong>只读数据段.rdata</strong><br>	- 虚函数表的布局顺序与类定义中虚函数的声明顺序相同，除了新增的虚函数会排在继承自基类的虚函数之后<br>		- 编译器根据虚函数在类中的位置，从虚函数表中查找相应位置的函数地址。<br>		- 重写的虚函数在虚函数表的对应位置就是重写后的地址，不重写的虚函数其地址是基类地址<br><strong>虚指针__vptr</strong>：指向该类的虚拟表的隐藏指针成员<br>			- 实例：<br>			在创建 Base 类型的对象时，<code>*__vptr</code> 设置为指向 Base 的虚拟表。构造 D1 或 D2 类型的对象时，<code>*__vptr</code> 将分别设置为指向 D1 或 D2 的虚拟表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    VirtualTable* __vptr;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">function1</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">function2</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function1</span><span class="params">()</span> override &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function2</span><span class="params">()</span> override &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    D1 d1 &#123;&#125;;</span><br><span class="line">    Base* dPtr = &amp;d1;</span><br><span class="line">    dPtr-&gt;function1();      </span><br><span class="line">    <span class="comment">//必须执行 3 次操作才能找到要调用的函数：首先，程序识别出 function1（） 是一个虚函数。其次，该程序使用 `dPtr-&gt;__vptr` 来访问 D1 的虚拟表。最后，它查找要在 D1 的虚拟表中调用哪个版本的 function1（）。这已经被设置为 D1：：function1（） 了。因此，`dPtr-&gt;function1（）` 解析为 D1：：function1（）！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各个类的虚表如下：</p>

<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul>
<li>在我们想要限制用户覆盖函数的情况下，可以使用final说明符，表示重写行为到此类为止</li>
<li>重写带有final的函数，编译器将给出编译错误</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">	virtual <span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	<span class="comment">// note use of final specifier on following line -- that makes this function not able to be overridden in derived classes</span></span><br><span class="line">	<span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> override final &#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125; <span class="comment">// okay, overrides A::getName()</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> public B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	<span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> override &#123; <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>; &#125; <span class="comment">// compile error: overrides B::getName(), which is final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在我们想要阻止从类继承的情况下，final 说明符应用在类名之后,例如 class B <strong>final</strong> : public A</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">	virtual <span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">final</span> :</span> public A <span class="comment">// note use of final specifier here</span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	<span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> override &#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> public B <span class="comment">// compile error: cannot inherit from final class</span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	<span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> override &#123; <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="虚拟析构函数"><a href="#虚拟析构函数" class="headerlink" title="虚拟析构函数"></a>虚拟析构函数</h4><ul>
<li>基类和派生类类最好都<strong>将析构函数设置为虚函数和public</strong><ul>
<li>原因：析构函数声明为虚函数可以确保在通过<strong>基类指针删除派生类对象</strong>时，可以正确地调用派生类的析构函数。这样可以避免内存泄漏和资源泄漏。<ul>
<li>如果不是虚函数，使用基类引用或指针指向派生类对象，当删除指针或引用时，就会<strong>只调用基类的析构函数</strong>，而不会调用派生类的析构函数，应该被删除的派生类的成员就不会被删除,程序将面临内存泄漏的风险。</li>
<li>当派生类对象被销毁时，基类的析构函数会自动被调用</li>
</ul>
</li>
<li>构造函数不能是虚函数<ul>
<li>原因：虚函数依赖于完整的对象和已建立的虚函数表，因此在构造一个对象时，由于对象还未创建成功，也没有建立好虚表，是没法调用虚函数的</li>
</ul>
</li>
<li>例如：下面derived的成员m_array就不会被删除</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">	<span class="comment">//正确做法： virtual ~Base() </span></span><br><span class="line">    ~Base() <span class="comment">// note: not virtual</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> public Base</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span>* m_array &#123;&#125;;</span><br><span class="line">    <span class="comment">//正确做法： virtual ~Derived()  </span></span><br><span class="line">    ~Derived() <span class="comment">// note: not virtual (your compiler may warn you about this)</span></span><br><span class="line">    &#123;</span><br><span class="line">        delete[] m_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Derived* derived &#123; new Derived(<span class="number">5</span>) &#125;;</span><br><span class="line">    Base* base &#123; derived &#125;;</span><br><span class="line"></span><br><span class="line">    delete base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="忽略虚函数"><a href="#忽略虚函数" class="headerlink" title="忽略虚函数"></a>忽略虚函数</h4><ul>
<li>极少数情况下，您可能希望忽略函数的虚拟化，那么使用scope resolution 运算符::指定应该调用的函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Derived derived &#123;&#125;;</span><br><span class="line">    <span class="type">const</span> Base&amp; base &#123; derived &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calls Base::getName() instead of the virtualized Derived::getName()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; base.Base::getName() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h4><p>当一个类继承多个具有相同祖宗类的类时，需要用到虚基类避免多次构造祖宗类<br>实例：</p>
<ul>
<li>对于最派生类的构造函数，<strong>虚基类始终在非虚拟基类之前创建</strong></li>
<li>如果一个类继承了一个或多个具有虚拟父类的类，<strong>则最底层的派生类负责构造虚拟基类</strong>。在本例中，Copier 继承了 Printer 和 Scanner，两者都有一个 PoweredDevice 虚拟基类。 Copier 是最底层的派生类，负责创建 PoweredDevice。</li>
<li>继承虚基类的所有类都将有一个虚拟表，并且该类的所有派生类也会拥有一个虚拟表，用于访问子对象的成员  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoweredDevice</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span>:</span> virtual public PoweredDevice.    <span class="comment">//PoweredDevice成了虚基类</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span> virtual public PoweredDevice。   <span class="comment">//PoweredDevice成了虚基类</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Copier</span>:</span> public Scanner, public Printer.   <span class="comment">//copier继承两个虚基类，但只构造一次PoweredDevice</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="名称隐藏"><a href="#名称隐藏" class="headerlink" title="名称隐藏"></a>名称隐藏</h4><p>如果子类定义了一个与父类虚函数同名的新函数（即使参数不同），在子类作用域中会导致同名函数的隐藏。此时，父类中所有同名的重载函数都被隐藏，不再可见。<br>	例如父类有n个重载的print函数，子类有一个自己的print函数，那么子类只能调用自己的那个print函数, 就算是调用父类的虚print函数也没用</p>
<p>可以通过使用<strong>using 解决名称隐藏问题</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    using Base::func;  <span class="comment">// 引入 Base 的所有 func 重载版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> x)</span> override &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::func(int) called with &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">char</span> x)</span> &#123;  <span class="comment">// 新增的函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived::func(char) called with &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="友元函数的重写"><a href="#友元函数的重写" class="headerlink" title="友元函数的重写"></a>友元函数的重写</h4><ul>
<li>友元函数不是类的成员函数，不能被继承，因此是无法被重写override的，但可以重载overload<ul>
<li>那么如何让继承类使用基类的友元函数？答案是在友元函数中调用一个虚普通成员函数</li>
<li>实例：</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">	<span class="comment">// Here&#x27;s our overloaded operator&lt;&lt;</span></span><br><span class="line">	friend <span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; out, <span class="type">const</span> Base&amp; b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Call virtual function identify() to get the string to be printed</span></span><br><span class="line">		out &lt;&lt; b.identify();</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We&#x27;ll rely on member function identify() to return the string to be printed</span></span><br><span class="line">	<span class="comment">// Because identify() is a normal member function, it can be virtualized</span></span><br><span class="line">	virtual <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">identify</span><span class="params">()</span> <span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Base&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	<span class="comment">// Here&#x27;s our override identify() function to handle the Derived case</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">identify</span><span class="params">()</span> <span class="type">const</span> override</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Derived&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Base b&#123;&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	Derived d&#123;&#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 继承类成员也能正确调用，因为在调用Base的&lt;&lt;时Derived发生了隐式的向上转换，Derived&amp;转换为了Base&amp;，然后调用identify（）时发生了虚函数解析，解析为了Derived的版本</span></span><br><span class="line">	Base&amp; bref&#123; d &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bref &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol>
<li>下面的基类指针rBase是指向派生类Derived的引用，那么rBase.getName()将调用哪个类的函数？</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Base&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Derived&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Derived derived &#123;&#125;;</span><br><span class="line">    Base&amp; rBase&#123; derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rBase is a &quot;</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>那么下面重写虚函数后，rBase.getName()将调用哪个类的函数？</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Base&quot;</span>; &#125; <span class="comment">// note addition of virtual keyword</span></span><br><span class="line">    virtual ~Base() = <span class="keyword">default</span>;          <span class="comment">//基类的析构函数最好也要变为虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual <span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Derived&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Derived derived &#123;&#125;;</span><br><span class="line">    Base&amp; rBase&#123; derived &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rBase is a &quot;</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当 <em>rBase.getName（）</em> 被计算时，它通常会解析为 Base：：getName（）。但是，Base：：getName（） 是虚函数的，它告诉程序去查看是否有可用于 Derived 对象的函数的更多派生版本。在这种情况下，它将解析为 Derived：：getName（）！</p>
<ol start="3">
<li>下面将打印什么？</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// note: no virtual keyword in B, C, and D</span></span><br><span class="line">    <span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> public B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> public C</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::string_view <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="string">&quot;D&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    C c &#123;&#125;;</span><br><span class="line">    B&amp; rBase&#123; c &#125;; <span class="comment">// note: rBase is a B this time</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rBase.getName() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C. 即使 B 和 C 未标记为虚函数，A::getName（） 是虚函数，那么B：：getName（） 和 C：：getName（） 是隐式的虚函数。</p>

      </div>
    </div>
    
      <script src='https://unpkg.com/mermaid@latest/dist/mermaid.min.js'></script>
      <script>
        if (window.mermaid) {
          mermaid.initialize({"startOnload":true});
        }
      </script>
    
  </article>
  <div class="post__foot">
    
      <div class="like-author">
  <input type="checkbox" id="likeCode" />
  <div class="author-face">
    <img height="100px"
         width="100px"
         id="front-face"
         alt="author face"
         src="/assets/author-face.jpg" />
    <img height="100px"
         width="100px"
         id="back-face"
         alt="like code"
         src="/assets/pay-code.jpg" />
  </div>
  <div class="like-text">“给作者倒杯卡布奇诺”</div>
  <label for="likeCode" class="like-btn">
    <svg viewBox="0 0 1024 1024"
         width="20px"
         style="margin-right: 10px"
         height="20px">
      <path d="M466.88 908.96L113.824 563.296a270.08 270.08 0 0 1 0-387.392c108.8-106.56 284.896-106.56 393.696 0 1.504 1.472 2.976 2.944 4.448 4.48 1.472-1.536 2.944-3.008 4.448-4.48 108.8-106.56 284.896-106.56 393.696 0a269.952 269.952 0 0 1 34.016 347.072l-387.392 385.6a64 64 0 0 1-89.92 0.384z" p-id="13650" fill="#ee4242" />
    </svg>
    喜欢作者
  </label>
</div>

    
    <div class="post-nav">
  
    <a class="post-nav-item-left" href="/2024/11/09/note/cuda/CUDA%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%92%8Cbank%20conflict/">
      <div class="text-align">
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596" />
        </svg>
        <span class="text-small">上一篇</span>
      </div>
      <div>CUDA笔记——共享内存和bank conflict</div>
    </a>
  
  <div class="vhr"></div>
  
    <a class="post-nav-item-right" href="/2024/09/07/note/c++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%B1%BB/">
      <div class="text-align">
        <span class="text-small">下一篇</span>
        <svg t="1670570876164"
             class="icon"
             viewBox="0 0 1024 1024"
             transform="scale(-1,-1)"
             width="16"
             height="16">
          <path d="M384 512L731.733333 202.666667c17.066667-14.933333 19.2-42.666667 4.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384 341.333333c-10.666667 8.533333-14.933333 19.2-14.933334 32s4.266667 23.466667 14.933334 32l384 341.333333c8.533333 6.4 19.2 10.666667 27.733333 10.666667 12.8 0 23.466667-4.266667 32-14.933333 14.933333-17.066667 14.933333-44.8-4.266667-59.733334L384 512z" p-id="14596" />
        </svg>
      </div>
      c++学习笔记——类
    </a>
  
</div>

    
    
  </div>

    </div>
    <div class="foot">
  <div class="foot-inner">
    <div class="foot__head">
      
        <div class="foot-line">
          <div class="matts">海</div><div class="matts">内</div><div class="matts">存</div><div class="matts">知</div><div class="matts">己</div>
        </div>
      
        <div class="foot-line">
          <div class="matts">天</div><div class="matts">涯</div><div class="matts">若</div><div class="matts">比</div><div class="matts">邻</div>
        </div>
      
    </div>
    <div class="foot__body">
      
      
        <div class="foot-item">
          <div class="foot-item__head">账号</div>
          <div class="foot-item__body">
            


  
  
    <div class="foot-link-group">
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/logo-github.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://github.com/Felt98">Felt's Github</a>
          </div>
        
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/logo-zh.svg" />
            <a class="foot-link" target="_blank" rel="noopener" href="https://www.zhihu.com/people/yi-ming-81-1">Felt</a>
          </div>
        
      
        
        
      
        
        
      
    </div>
  


          </div>
        </div>
      
      <div class="foot-item">
        <div class="foot-item__head">联系</div>
        <div class="foot-item__body">
          


  
  
    <div class="foot-link-group">
      
        
        
          <div class="text">
            <img alt="link"
                 height="20px"
                 width="20px"
                 src="/images/icon/icon-email.svg" />
            <a class="foot-link" href="mailto:haoqingqin@gmail.com">haoqingqin@gmail.com</a>
          </div>
        
      
        
        
      
        
        
      
        
        
      
    </div>
  


        </div>
      </div>
    </div>
    <div class="copyright">
      <a href="http://example.com">Felt's blog</a> &nbsp;|&nbsp;由&nbsp;<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>&nbsp;及&nbsp;
      <svg width="20" height="20" viewBox="0 0 725 725">
        <path fill-rule="evenodd" fill="rgb(221, 221, 221)" d="M145.870,236.632 L396.955,103.578 L431.292,419.44 L156.600,522.53 L145.870,236.632 Z" />
        <path fill-rule="evenodd" fill="rgb(159, 159, 159)" d="M396.955,103.578 L564.345,234.486 L611.558,513.469 L431.292,419.44 L396.955,103.578 Z" />
        <path fill-rule="evenodd" fill="rgb(0, 0, 0)" d="M431.292,419.44 L611.558,513.469 L358.327,595.18 L156.600,522.53 L431.292,419.44 Z" />
      </svg>
      <a target="_blank" rel="noopener" href="https://github.com/hooozen/hexo-theme-tranquility">致远</a>&nbsp;驱动
    </div>
  </div>
</div>

    
    
      <script src="/js/search.js"></script>
      <script>searchInitialize("/search.json")</script>
    
    <script src="/js/copy-code.js"></script>
    
  

  </body>
</html>
