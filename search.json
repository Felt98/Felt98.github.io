[{"title":"合并访存","url":"/2025/02/16/合并访存/","content":"## 合并访存\n\n合并访存：当同一**warp**中的线程访问**连续且对齐**的全局内存地址时，硬件可将这些访问合并为单个或更少的内存事务。这样通过合并访问内存事务来增加内存带宽利用率\n> \t- 例如，32个线程（一个warp）访问连续的32个`float`（每个4字节），合并为一次128字节的事务。\n 读全局内存的基本单位是1 sector，即32 byte\n\n合并率： warp请求的字节数 /  请求传输的总字节数。 合并率越高，访存性能越好\n合并访存是在一个wrap中，因此要以wrap负责的数据来调整\n- **add1**\n正常的读写连续且对齐的内存，每天指令请求的4个sector中的数据都得到了利用，合并率100%\n![](合并访存/img-合并访存-ddac88da-c650-45c8-acce-c0b0fe975fc0.png)\n- **add2**\n不对齐的读取数据（不从头开始访问），会造成多发送了一个sector，合并率 = 128/ （32 * 5）= 80%\n![](合并访存/img-合并访存-a069dde9-4db2-405e-a9c5-38375f0aebef.png)\n- **add3**\n线程乱序访问，当warp整体访问的内存还是连续且对齐的，性能与add1一样\n![](合并访存/img-合并访存-fa49fec4-b295-4153-88b9-6fcfa7e68d16.png)\n- **add4**\nwarp中每个线程都读写同一个数据，虽然只要一个float，但读取内存至少要1个sector，造成了浪费\n![](合并访存/img-合并访存-71e359d4-611f-4d43-9cd4-acf89c938fd7.png)\n- **add5**\n每个线程读写的数据之间间隔4，导致了线程读写内存之间是不连续的，要读取16个连续的sector才能将请求的数据覆盖到，合并率 = 4/16 = 25%\n![](合并访存/img-合并访存-1ab0f54a-eee4-4c2d-83d7-f70f2ac4c274.png)\n\n## 矩阵转置\nnative实现：\n```cpp\n/* N是长，M是宽*/\n__global__ void transpose_naive(float* input, float* output,int N, int M)\n{\n    // 原矩阵上点列id和行id\n    //注意y是行\n    int col_idx = blockIdx.x * blockDim.x + threadIdx.x;\n    int row_idx = blockIdx.y * blockDim.y + threadIdx.y;\n\n    // 这里input和output使用的都是一级指针，因此需要算出来每个点\n    // 在原始matrix上相对于Input的偏移\n    // 在transpose后的matrix上相对于output的偏移\n    if (col_idx < N && row_idx < M) {\n       // M * N的矩阵\n       int idx = row_idx * N + col_idx;\n       // N * M的矩阵\n       // 原matrix上的行、列变成新matrix上的列、行\n       int trans_idx = col_idx * M + row_idx;\n       output[trans_idx] = input[idx];\n    }\n}\n```\n### 改变线程的排布\n改变线程的排布可以提高合并率\n#### v1\n- 对于输入M=2048， N=512的矩阵，block_size取width=32, height=8,结果如下:\n![](合并访存/img-合并访存-96c60767-dcc0-43b9-aeb0-4c5fcc553714.png)\n读数据是没有问题的，32个线程取32个float，一共128 byte，即4个sector\n**但写数据时出现了问题**： 32个float写入时的数据是完全不连续的，但每次访存至少读取1个sector，这就造成了28byte * 32 的浪费\n> 这里写数据的合并率为 4/32= 12.5%\n\n#### v2\n- 将线程的排布变成(16,16)\n![](合并访存/img-合并访存-e3c06d15-bc4c-4f15-8c0a-882badb8ca94.png)\n这时4个sector分布在两行，这样增加了写数据的合并率。\n写数据的时候就减少了一个float的浪费，浪费的数据为 24 byte * 32\n\n- 将线程的排布变成(16,16)\n![](合并访存/img-合并访存-3159b4a1-33e5-47f9-943a-d1d7d6fc9215.png)\n这时4个sector分布在4行\n写数据的时候一个sector 里面可以写入4个float的数据，浪费的数据为 16 byte * 32\n\n为什么不能将线程行数一直缩小变成(4,64),(2,128)来提高write的合并率: \n\t这样做会使读数据的时候降低数据的合并率。因为一个float 4 byte，那么读一个sector最多被8个线程利用，如果这8个线程分布在不同行，一次访存取出的sector就会有浪费。\n\t这也启示我们，设置线程数量要尽量确保读写连续的内存，且一次读写至少是32字节，这样就能合并访存\n### 使用float4\n一个线程处理多个数据，可以提高写数据的合并率\n#### v1_float4\nblockSize还是(32,8)的排布，但是一个线程处理一个4 * 4的矩阵（4个float4数据），先在寄存器中进行转置，然后写会\n写数据的合并率 = 4 * 4 /32 =50%\n![](合并访存/img-合并访存-be147936-6872-49f9-94c7-faec41930de4.png)\n```c\n__global__ void tanspose(float *input, float *output, int N, int M)\n\n{\n    // 先在寄存器内做好转置，再写回output\n    // 因此先声明两个4*4的寄存器数组\n    // 也可以使用共享内存，在block内进行转置，不过可能会出现bank conflict\n\n    int col = (blockDim.x * blockIdx.x + threadIdx.x) * 4; // x是列\n    int row = (blockDim.y * blockIdx.y + threadIdx.y) * 4;\n    if (col >= N || row >= M)\n        return;\n\n    float r_input[4][4];\n    float r_output[4][4];\n\t//取intput[row+i][col]到r_input[i]\n    for (int i = 0; i < 4; i++)\n    {\n        FLOAT4(r_input[i]) = FLOAT4(intput[(row + i) * N + col]);\n    }\n\n    // 4*4矩阵内转置\n    for (int i = 0; i < 4; i++)\n    {\n        FLOAT4(r_output[i]) = make_float4(r_input[0][i], r_input[1][i], r_input[2][i],r_input[3][i]); // 把rinput的列变成float4然后写入routput的行\n    }\n    \n\t// r_output[i]写入output[col+i][row]转置矩阵\n    for (int i = 0; i < 4; i++)\n    {\n        FLOAT4(output[(col + i) * M + row]) = FLOAT4(r_output[i]); \n    }\n\n    return;\n\n}\n```\n\n#### v2_float4\nblockSize修改为(16,16)的排布，那么写入数据就能尽可能地合并访存了\n![](合并访存/img-合并访存-cb75a8fd-0159-48a5-b1af-eff052030fc3.png)\n```c\nint main()\n{\n    dim3 block_size(16, 16);\n    // dim3 grid_size(N / 16, M / 16);\n    dim3 grid_size(CEIL(N / 16), CEIL(M / 16));\n}\n```\n\n","categories":["note"]},{"title":"end","url":"/2025/02/16/end/","content":"![](end/img-end-7594be68-c6a3-46e8-82c0-ebaf1d7405bd.png)"},{"title":"hello-world","url":"/2025/02/15/hello-world/","content":"![](hello-world/img-hello-world-25105651-6315-4d16-a5f0-05ea07dc4274.png)","categories":["hi"]},{"title":"hi","url":"/2025/01/24/hi/","content":"![](hi/img-hi-f20b79c7-2f62-4dec-bf5f-05805bfdf031.png)\n\n![](hi/img-hi-ba6424b1-8ec2-4187-a433-43014c113d13.png)"}]